### [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

给定单个链表的头 `head` ，使用 **插入排序** 对链表进行排序，并返回 *排序后链表的头* 。

**插入排序** 算法的步骤:

1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
3. 重复直到所有输入数据插入完为止。

下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。

对链表进行插入排序。

![img](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg)

```
输入: head = [4,2,1,3]
输出: [1,2,3,4]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg)

```
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

 

**提示：**



- 列表中的节点数在 `[1, 5000]`范围内
- `-5000 <= Node.val <= 5000`





##### **分治递归**



<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240305141412965.png" alt="image-20240305141412965" style="zoom:67%;" />





```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode temp = slow.next;
        slow.next = null;
        ListNode left = sortList(head);
        ListNode right = sortList(temp);
        ListNode p = new ListNode();
        ListNode dummy = p;
        //合并两个有序链表
        while(left != null && right != null){
            if(left.val < right.val){
                p.next = left;
                left = left.next;
            }else{
                p.next = right;
                right = right.next;
            }
            p = p.next;
        }
        if(left != null){
            p.next = left;
        }else{
            p.next = right;
        }
        return dummy.next;

    }
}
```

时间复杂度：$O（n * log n）$